<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Renju Dojo 連珠道場 – Tasuku Ono</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-35775312f623334fe0cde8345bd217f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZBV5W7QD1W"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ZBV5W7QD1W', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="styles.css">
<meta name="twitter:title" content="Renju Dojo 連珠道場 – Tasuku Ono">
<meta name="twitter:creator" content="@PlusNineOnZero">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Tasuku Ono</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./natural-languages.html"> 
<span class="menu-text">Natural Languages</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./renju_home.html"> 
<span class="menu-text">2D Ising Model</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Renju Dojo 連珠道場</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Renju Dojo 連珠道場</h1>
</div>



<div class="quarto-title-meta column-page-right">

    
  
    
  </div>
  


</header>


<div class="controls">
  <div class="row">
    <label>Play as:</label>
    <select id="side-select">
      <option value="human-black">Black (forbidden moves apply)</option>
      <option value="human-white" selected="">White</option>
    </select>
    <label class="sp">AI level:</label>
    <select id="level-select">
      <option value="0" selected="">Easy</option>
      <option value="1">Hard</option>
    </select>
    <button id="newgame">New Game</button>
    <button id="undo">Undo</button>
    <button id="aigo">AI Move</button>
  </div>
  <div id="status">Loading…</div>
</div>

<div class="board-wrap">
  <canvas id="board" width="640" height="640" aria-label="Renju board" role="img"></canvas>
</div>

<div class="help">
  <details>
    <summary>Rules this page enforces</summary>
    <ul>
      <li>Board size: 15×15. Exactly 5-in-a-row wins for Black; ≥5 wins for White. Black may not win by overline (6+).</li>
      <li>Black forbidden moves: overline, double-three, double-four. If a legal move makes exactly five, Black wins even if it simultaneously forms threes/fours.</li>
      <li>Opening rules like Swap / Soosõrv are <em>not</em> enforced here.</li>
    </ul>
  </details>
</div>

<style>
:root { --bg:#fafaf8; --grid:#c9a878; --star:#a07b3a; }
body { background: var(--bg); font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
.board-wrap { display:flex; justify-content:center; margin: 8px 0 24px; }
.controls { max-width: 960px; margin: 0 auto 8px; padding: 8px 12px; }
.controls .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
.controls label { font-weight:600; }
controls .sp { margin-left: 6px; }
#status { margin-top: 6px; font-weight:600; }
button, select { border:1px solid #ddd; border-radius:10px; padding:6px 10px; background:#fff; cursor:pointer; }
button:hover { box-shadow: 0 1px 8px rgba(0,0,0,0.06); }
.help { max-width:960px; margin: 0 auto 24px; color:#444; }
summary { cursor:pointer; }
</style>

<script>
(function(){
  const N = 15; const EMPTY=0, BLACK=1, WHITE=2;
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const MARGIN = 32, SIZE = canvas.width, CELL = (SIZE - 2*MARGIN)/(N-1);
  const STAR_PTS = [[3,3],[3,11],[7,7],[11,3],[11,11]];
  const sideSelect = document.getElementById('side-select');
  const levelSelect = document.getElementById('level-select');
  const statusEl = document.getElementById('status');
  const btnNew = document.getElementById('newgame');
  const btnUndo = document.getElementById('undo');
  const btnAi = document.getElementById('aigo');

  let board, turn, history, winner, lastMove, humanPlays, aiPlays;

  function reset(){
    board = Array.from({length:N}, ()=>Array(N).fill(EMPTY));
    history = []; winner = null; lastMove = null; turn = BLACK;
    humanPlays = sideSelect.value === 'human-black' ? BLACK : WHITE;
    aiPlays = humanPlays===BLACK? WHITE : BLACK;
    draw();
    status(`New game. You are ${humanPlays===BLACK?'Black':'White'}. ${humanPlays===WHITE?'Computer (Black) to move.':'Your move.'}`);
    if (aiPlays===BLACK) aiMove();
  }

  function toXY(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width/rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height/rect.height);
    let c = Math.round((x - MARGIN)/CELL);
    let r = Math.round((y - MARGIN)/CELL);
    if (r<0||r>=N||c<0||c>=N) return null;
    const px = MARGIN + c*CELL, py = MARGIN + r*CELL;
    const dist = Math.hypot(px-x, py-y);
    if (dist>CELL*0.45) return null;
    return {r, c};
  }

  function draw(){
    ctx.clearRect(0,0,SIZE,SIZE);
    ctx.fillStyle = '#f2e5c7'; ctx.fillRect(0,0,SIZE,SIZE);
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid')||'#c9a878'; ctx.lineWidth = 1;
    for (let i=0;i<N;i++){
      const p = MARGIN + i*CELL;
      ctx.beginPath(); ctx.moveTo(MARGIN, p); ctx.lineTo(SIZE-MARGIN, p); ctx.stroke();
    }
    for (let i=0;i<N;i++){
      const p = MARGIN + i*CELL;
      ctx.beginPath(); ctx.moveTo(p, MARGIN); ctx.lineTo(p, SIZE-MARGIN); ctx.stroke();
    }
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--star')||'#a07b3a';
    STAR_PTS.forEach(([r,c])=>{ const x = MARGIN + c*CELL, y = MARGIN + r*CELL; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); });
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){ if (board[r][c]) drawStone(r,c,board[r][c]); }
    if (lastMove){ const {r,c}=lastMove; const x=MARGIN+c*CELL, y=MARGIN+r*CELL; ctx.strokeStyle='#3a86ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,CELL*0.22,0,Math.PI*2); ctx.stroke(); }
    if (winner){ ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,SIZE/2-24,SIZE,48); ctx.fillStyle='#fff'; ctx.font='700 22px system-ui, ui-sans-serif, -apple-system, Segoe UI, Roboto'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(`${winner===BLACK?'Black':'White'} wins!`, SIZE/2, SIZE/2); ctx.restore(); }
  }
  function drawStone(r,c,color){
    const x = MARGIN + c*CELL, y = MARGIN + r*CELL, rad = CELL*0.32;
    const g = ctx.createRadialGradient(x-rad*0.3,y-rad*0.3,rad*0.2, x,y,rad);
    if (color===BLACK){ g.addColorStop(0,'#444'); g.addColorStop(1,'#111'); } else { g.addColorStop(0,'#fafafa'); g.addColorStop(1,'#d0d0d0'); }
    ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fillStyle=g; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke();
  }
  function status(msg){ statusEl.textContent = msg; }
  function onClick(ev){ if (winner) return; const pos = toXY(ev); if (!pos) return; humanTryMove(pos.r,pos.c); }

  function humanTryMove(r,c){
    if (board[r][c]!==EMPTY) return;
    if (turn !== humanPlays) return;
    const forb = (humanPlays===BLACK) ? forbiddenIfBlackMove(r,c) : null;
    if (forb && forb.forbidden){ status(`Illegal for Black: ${forb.reason}. Try another move.`); return; }
    doMove(r,c,humanPlays);
    if (!winner) aiMove();
  }

  function doMove(r,c,color){
    board[r][c]=color; lastMove={r,c}; history.push({r,c,color});
    const lineLen = maxLineThrough(r,c,color);
    if (color===BLACK){ if (lineLen===5) winner=BLACK; } else { if (lineLen>=5) winner=WHITE; }
    turn = (color===BLACK) ? WHITE : BLACK;
    draw();
    status(winner ? `${winner===BLACK?'Black':'White'} wins!` : `${turn===humanPlays? 'Your' : 'Computer'} move…`);
  }

  function undo(){ if (!history.length || winner) return; const steps = (history.length>=2)?2:1; for (let i=0;i<steps;i++){ const m=history.pop(); board[m.r][m.c]=EMPTY; } winner=null; lastMove=history[history.length-1]||null; turn=BLACK; if (history.length){ const last=history[history.length-1]; turn=(last.color===BLACK)?WHITE:BLACK; } draw(); status('Undid.'); }

  function maxLineThrough(r,c,color){
    let best=1; const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    for (const [dr,dc] of dirs){
      let cnt=1; let rr=r+dr, cc=c+dc; while(inB(rr,cc)&&board[rr][cc]===color){cnt++; rr+=dr; cc+=dc;}
      rr=r-dr; cc=c-dc; while(inB(rr,cc)&&board[rr][cc]===color){cnt++; rr-=dr; cc-=dc;}
      if (cnt>best) best=cnt;
    }
    return best;
  }
  function inB(r,c){ return r>=0&&r<N&&c>=0&&c<N; }

  // --- Forbidden for Black ---
  function forbiddenIfBlackMove(r,c){
    board[r][c]=BLACK;
    const len = maxLineThrough(r,c,BLACK);
    if (len>5){ board[r][c]=EMPTY; return {forbidden:true, reason:'overline (6+)'}; }
    if (len===5){ board[r][c]=EMPTY; return {forbidden:false, reason:null}; }
    const {fours, threes} = countThreatsAt(r,c,BLACK);
    board[r][c]=EMPTY;
    if (fours>=2) return {forbidden:true, reason:'double-four'};
    if (threes>=2) return {forbidden:true, reason:'double-three'};
    return {forbidden:false, reason:null};
  }

  function lineStringAround(r,c,color, dr,dc){
    const me=color; let cells=[], coords=[];
    let rr=r-10*dr, cc=c-10*dc; while(!inB(rr,cc)){ rr+=dr; cc+=dc; }
    for (; inB(rr,cc); rr+=dr,cc+=dc){
      coords.push([rr,cc]);
      const v=board[rr][cc];
      if (rr===r && cc===c) cells.push('x');
      else if (v===EMPTY) cells.push('.');
      else if (v===me) cells.push('x');
      else cells.push('o');
    }
    const s=cells.join(''); const idx = coords.findIndex(p=>p[0]===r&&p[1]===c);
    return {s, idx, coords};
  }

  function countThreatsAt(r,c,color){
    const dirs=[[1,0],[0,1],[1,1],[1,-1]]; let fours=0, threes=0;
    const fourPats=[/xxxx\./g,/\.xxxx/g,/xxx\.x/g,/x\.xxx/g,/xx\.xx/g,/\.xxxx\./g];
    const threePats=[/\.xxx\./g,/\.xx\.x\./g,/\.x\.xx\./g];
    for (const [dr,dc] of dirs){
      const {s, idx} = lineStringAround(r,c,color, dr,dc);
      let dirHasFour=false, dirHasThree=false;
      for (const re of fourPats){ re.lastIndex=0; let m; while((m=re.exec(s))){ if (m.index<=idx && idx<m.index+m[0].length){ dirHasFour=true; break; } } if (dirHasFour) break; }
      if (dirHasFour) fours += 1;
      for (const re of threePats){ re.lastIndex=0; let m; while((m=re.exec(s))){ if (m.index<=idx && idx<m.index+m[0].length){ dirHasThree=true; break; } } if (dirHasThree) break; }
      if (dirHasThree) threes += 1;
    }
    return {fours, threes};
  }

  function emptyCells(){
    const cells=[];
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]===EMPTY) cells.push({r,c});
    return cells;
  }
  function hasNeighbor(r,c,dist){
    for (let dr=-dist; dr<=dist; dr++){
      for (let dc=-dist; dc<=dist; dc++){
        if (!dr && !dc) continue;
        const rr=r+dr, cc=c+dc;
        if (inB(rr,cc) && board[rr][cc]!==EMPTY) return true;
      }
    }
    return false;
  }
  function stonesPlaced(){
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]!==EMPTY) return true;
    return false;
  }

  // Free-three detection now covers .xxx., .xx.x., .x.xx. in all directions (including diagonals)
  function localFreeThreeBlocksFrom(r,c, opp){
    const dirs=[[0,1],[1,0],[1,1],[1,-1]]; const blocks=[]; const seen=new Set();
    const re = /\.xxx\.|\.xx\.x\.|\.x\.xx\./g;
    for (const [dr,dc] of dirs){
      const {s, idx, coords} = lineStringAround(r,c, opp, dr,dc);
      re.lastIndex = 0; let m;
      while((m = re.exec(s))){
        const start = m.index, pat = m[0];
        const candidates = [];
        if (pat === '.xxx.') { candidates.push(coords[start], coords[start+4]); }
        else if (pat === '.xx.x.') { candidates.push(coords[start+3]); }
        else if (pat === '.x.xx.') { candidates.push(coords[start+2]); }
        if (start <= idx && idx <= start+4){
          for (const [rr,cc] of candidates){
            const key = rr+','+cc;
            if (inB(rr,cc) && board[rr][cc]===EMPTY && !seen.has(key)){ seen.add(key); blocks.push({r:rr,c:cc}); }
          }
        }
      }
    }
    return blocks;
  }

  function currentFreeThreeBlocks(opp){
    const blocks=[]; const seen=new Set();
    const dirs=[[0,1],[1,0],[1,1],[1,-1]];
    const re = /\.xxx\.|\.xx\.x\.|\.x\.xx\./g;
    function considerLine(r0,c0,dr,dc){
      let r=r0, c=c0; const coords=[]; const chars=[];
      while (inB(r,c)){ coords.push([r,c]); const v=board[r][c]; chars.push(v===0?'.':(v===opp?'x':'o')); r+=dr; c+=dc; }
      const s = chars.join(''); re.lastIndex = 0; let m;
      while((m=re.exec(s))){
        const start=m.index, pat=m[0]; const cand=[];
        if (pat === '.xxx.') { cand.push(coords[start], coords[start+4]); }
        else if (pat === '.xx.x.') { cand.push(coords[start+3]); }
        else if (pat === '.x.xx.') { cand.push(coords[start+2]); }
        for (const [rr,cc] of cand){
          const key=rr+','+cc;
          if (board[rr][cc]===EMPTY && !seen.has(key)){ seen.add(key); blocks.push({r:rr,c:cc}); }
        }
      }
    }
    for (let r=0;r<N;r++) considerLine(r,0,0,1);
    for (let c=0;c<N;c++) considerLine(0,c,1,0);
    for (let k=0;k<N;k++) considerLine(k,0,1,1);
    for (let k=1;k<N;k++) considerLine(0,k,1,1);
    for (let k=0;k<N;k++) considerLine(k,0,-1,1);
    for (let k=1;k<N;k++) considerLine(N-1,k,-1,1);
    return blocks;
  }

  function createsOpenFour(color, r, c){
    board[r][c]=color;
    const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    let ok=false;
    for (const [dr,dc] of dirs){
      const {s} = lineStringAround(r,c,color, dr,dc);
      if (/\.(xxxx)\./.test(s)) { ok=true; break; }
    }
    board[r][c]=EMPTY;
    return ok;
  }

  function evalMove(color, r, c){
    if (!inB(r,c) || board[r][c]!==EMPTY) return -1e18;
    board[r][c]=color;
    const len = maxLineThrough(r,c,color);
    const t = countThreatsAt(r,c,color);
    let sc = 0;
    if ((color===BLACK && len===5) || (color===WHITE && len>=5)) sc += 1e7;
    sc += 150*len + 5200*t.fours + 1600*t.threes;
    const dx = Math.abs(c - 7), dy = Math.abs(r - 7);
    sc += 40 * (7 - Math.max(dx,dy));
    board[r][c]=EMPTY;
    return sc;
  }

  function candidateMoves(color){
    if (!stonesPlaced()) return [{r:7,c:7}];
    const near=[]; const seen=new Set();
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){
      if (board[r][c]===EMPTY && hasNeighbor(r,c,2)){
        const k=r+','+c; if (!seen.has(k)){ seen.add(k); near.push({r,c}); }
      }
    }
    const pool = near.length ? near : emptyCells();
    const scored = pool.map(m => ({m, s: evalMove(color, m.r, m.c)}))
                       .sort((a,b)=> b.s - a.s)
                       .slice(0, 28)
                       .map(o=>o.m);
    return scored;
  }

  function safeLegal(color, r, c){
    return color===WHITE || !forbiddenIfBlackMove(r,c).forbidden;
  }

  const TT = new Map();

  function aiMove(){
    if (winner || turn!==aiPlays) return;
    const mode = parseInt(levelSelect.value,10)||0; // 0 Easy, 1 Hard
    const thinkMs = (mode===0)? 260 : 1800;
    status('Computer thinking…');

    const watchdog = setTimeout(()=>{
      let cands = candidateMoves(aiPlays).filter(m=> safeLegal(aiPlays, m.r, m.c));
      const best = cands.length ? cands[0] : null;
      if (turn===aiPlays && best){ doMove(best.r, best.c, aiPlays); }
    }, thinkMs + 700);

    setTimeout(()=>{
      try {
        const me = aiPlays, opp = (me===BLACK)?WHITE:BLACK;

        const myWin = immediateWinningMovesAll(me);
        if (myWin.length){
          const m = myWin.find(mm=> safeLegal(me, mm.r, mm.c)) || myWin[0];
          clearTimeout(watchdog); doMove(m.r, m.c, me); return;
        }

        const oppWins = immediateWinningMovesAll(opp);
        if (oppWins.length){
          const blockers = oppWins.filter(mm=> safeLegal(me, mm.r, mm.c));
          if (blockers.length){ clearTimeout(watchdog); doMove(blockers[0].r, blockers[0].c, me); return; }
        }

        let localBlocks = [];
        if (history.length && history[history.length-1].color===opp){
          const h = history[history.length-1];
          localBlocks = localFreeThreeBlocksFrom(h.r, h.c, opp).filter(mm=> safeLegal(me, mm.r, mm.c));
        }
        if (localBlocks.length){
          clearTimeout(watchdog);
          localBlocks.sort((a,b)=> (Math.abs(a.r-7)+Math.abs(a.c-7)) - (Math.abs(b.r-7)+Math.abs(b.c-7)));
          doMove(localBlocks[0].r, localBlocks[0].c, me); return;
        }

        const blocks = currentFreeThreeBlocks(opp).filter(mm=> safeLegal(me, mm.r, mm.c));
        if (blocks.length){
          clearTimeout(watchdog);
          blocks.sort((a,b)=> (Math.abs(a.r-7)+Math.abs(a.c-7)) - (Math.abs(b.r-7)+Math.abs(b.c-7)));
          doMove(blocks[0].r, blocks[0].c, me); return;
        }

        if (mode===1){
          const vct = findVCTMove(me, 6, Math.floor(thinkMs*0.5));
          if (vct && vct.move && safeLegal(me, vct.move.r, vct.move.c)){ clearTimeout(watchdog); doMove(vct.move.r, vct.move.c, me); return; }
          const vcf = findVCFMove(me, 8, Math.floor(thinkMs*0.3));
          if (vcf && vcf.move && safeLegal(me, vcf.move.r, vcf.move.c)){ clearTimeout(watchdog); doMove(vcf.move.r, vcf.move.c, me); return; }
        }

        const move = bestMoveTimed(me, thinkMs);
        clearTimeout(watchdog);
        if (!move){
          let cands = candidateMoves(me).filter(mm=> safeLegal(me, mm.r, mm.c));
          if (cands.length){ doMove(cands[0].r, cands[0].c, me); return; }
          status('AI passes (no legal moves).'); turn = humanPlays; return;
        }
        doMove(move.r, move.c, me);
      } catch (e){
        console.error('AI error:', e);
        clearTimeout(watchdog);
        let cands = candidateMoves(aiPlays).filter(mm=> safeLegal(aiPlays, m.r, m.c));
        const best = cands.length ? cands[0] : null;
        if (best) doMove(best.r, best.c, aiPlays);
        else { status('AI error; skipping move.'); turn = humanPlays; }
      }
    }, 10);
  }

  function staticEval(pov){
    const sb = sideScore(BLACK); const sw = sideScore(WHITE); const base = sb - sw;
    return (pov===BLACK? 1 : -1) * base;
  }
  function sideScore(color){
    let s=0; const opp=(color===BLACK)?WHITE:BLACK;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){
      if (board[r][c]===color){
        const len = maxLineThrough(r,c,color);
        const {fours, threes} = countThreatsAt(r,c,color);
        if (color===BLACK){ s += (len>=4?1500:0) + 135*len + 6000*fours + 1700*threes; }
        else { s += (len>=4?1700:0) + 145*len + 5200*fours + 1500*threes; }
      }
      if (board[r][c]===opp){ const {threes} = countThreatsAt(r,c,opp); s += 450*threes; }
    }
    return s;
  }

  function isWinningPlacement(color, r, c){
    if (board[r][c]!==EMPTY) return false;
    board[r][c]=color; const len = maxLineThrough(r,c,color);
    let win = (color===BLACK? (len===5) : (len>=5));
    if (color===BLACK && !win){ const chk = forbiddenIfBlackMove(r,c); if (chk.forbidden) win = false; }
    board[r][c]=EMPTY; return win;
  }

  function immediateWinningMovesAll(color){
    const out=[];
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){
      if (board[r][c]!==EMPTY) continue;
      if (color===BLACK && forbiddenIfBlackMove(r,c).forbidden) continue;
      if (isWinningPlacement(color, r, c)) out.push({r,c});
    }
    return out;
  }

  function bestMoveTimed(color, ms){
    const start = performance.now(); const deadline = start + ms;
    let best=null;
    const winNow = immediateWinningMovesAll(color)[0]; if (winNow) return winNow;
    TT.clear();
    for (let depth=2; depth<=8; depth++){
      const res = negamaxTT(color, depth, -1e18, 1e18, null, deadline);
      if (res.timedOut) break;
      if (res.move){ best = res.move; }
      if (performance.now()>deadline) break;
    }
    return best;
  }

  function boardKey(color, depth){
    let s=''; for (let r=0;r<N;r++) for (let c=0;c<N;c++) s += board[r][c];
    return s + '|' + color + '|' + depth;
  }

  function negamaxTT(color, depth, alpha, beta, last, deadline){
    if (performance.now()>deadline) return {score:0, move:null, timedOut:true};
    const opp = (color===BLACK)?WHITE:BLACK;

    if (last){
      const len = maxLineThrough(last.r,last.c,last.color);
      const lastWon = (last.color===BLACK) ? (len===5) : (len>=5);
      if (lastWon) return {score: -999999 + depth, move:null, timedOut:false};
    }
    if (depth===0){ return {score: staticEval(color), move:null, timedOut:false}; }

    const key = boardKey(color, depth); const probed = TT.get(key);
    if (probed && probed.depth>=depth){
      if (probed.flag==='EXACT') return {score: probed.score, move: probed.best, timedOut:false};
      if (probed.flag==='LOWER' && probed.score>alpha) alpha = probed.score;
      if (probed.flag==='UPPER' && probed.score<beta) beta = probed.score;
      if (alpha>=beta) return {score: probed.score, move: probed.best, timedOut:false};
    }

    let cands = candidateMoves(color).filter(mm=> safeLegal(color, mm.r, mm.c));
    if (!cands.length) return {score:0, move:null, timedOut:false};

    const winners=[]; const others=[];
    for (const m of cands){ if (isWinningPlacement(color,m.r,m.c)) winners.push(m); else others.push(m); }
    others.sort((a,b)=> evalMove(color,b.r,b.c) - evalMove(color,a.r,a.c));
    cands = winners.concat(others);

    let best=null; const origAlpha=alpha;
    for (const m of cands){
      board[m.r][m.c]=color;
      const res = negamaxTT(opp, depth-1, -beta, -alpha, {r:m.r,c:m.c,color}, deadline);
      board[m.r][m.c]=EMPTY;
      if (res.timedOut) return {score:0, move:best, timedOut:true};
      const val = -res.score;
      if (val>alpha){ alpha=val; best=m; }
      if (alpha>=beta) break;
    }
    const entry={depth, score:alpha, best, flag:(alpha<=origAlpha?'UPPER': (alpha>=beta?'LOWER':'EXACT'))};
    TT.set(key, entry);
    return {score: alpha, move: best, timedOut:false};
  }

  canvas.addEventListener('click', onClick);
  btnNew.addEventListener('click', ()=> reset());
  btnUndo.addEventListener('click', ()=> undo());
  btnAi.addEventListener('click', ()=> aiMove());
  sideSelect.addEventListener('change', ()=> reset());
  levelSelect.addEventListener('change', ()=> {
    const opt = levelSelect.options[levelSelect.selectedIndex];
    status(`Mode set to ${opt ? opt.text : levelSelect.value}.`);
  });

  reset();
})();
</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>