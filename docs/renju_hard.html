<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Renju Dojo 連珠道場 – Tasuku Ono</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-35775312f623334fe0cde8345bd217f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZBV5W7QD1W"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ZBV5W7QD1W', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="styles.css">
<meta name="twitter:title" content="Renju Dojo 連珠道場 – Tasuku Ono">
<meta name="twitter:creator" content="@PlusNineOnZero">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Tasuku Ono</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./natural-languages.html"> 
<span class="menu-text">Natural Languages</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./renju_home.html"> 
<span class="menu-text">2D Ising Model</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Renju Dojo 連珠道場</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Renju Dojo 連珠道場</h1>
</div>



<div class="quarto-title-meta column-page-right">

    
  
    
  </div>
  


</header>


<div class="controls">
  <div class="row">
    <label>Play as:</label>
    <select id="side-select">
      <option value="human-black" selected="">Black (forbidden moves apply)</option>
      <option value="human-white">White</option>
    </select>
    <button id="newgame">New Game</button>
    <button id="undo">Undo</button>
  </div>
  <div id="status">Your move…</div>
</div>

<div class="board-wrap">
  <canvas id="board" width="640" height="640" aria-label="Renju board" role="img"></canvas>
</div>

<style>
:root { --bg:#fafaf8; --grid:#c9a878; --star:#a07b3a; }
body { background: var(--bg); font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
.board-wrap{display:flex;justify-content:center;margin:8px 0 24px;padding:0 12px;max-width:100%;}
#board{width:min(94vw,640px);height:auto;max-width:100%;touch-action:manipulation;}
.controls{max-width:960px;margin:0 auto 8px;padding:8px 12px;}
.controls .row{display:flex;align-items:center;gap:10px;flex-wrap:wrap;}
.controls label{font-weight:600;}
#status{margin-top:6px;font-weight:600;}
button,select{border:1px solid #ddd;border-radius:10px;padding:6px 10px;background:#fff;cursor:pointer;}
button:hover{box-shadow:0 1px 8px rgba(0,0,0,0.06);}
</style>

<script>
(function(){
  const N=15, EMPTY=0, BLACK=1, WHITE=2;
  const canvas=document.getElementById('board');
  const ctx=canvas.getContext('2d');
  const SIZE=canvas.width;
  const MARGIN=32, CELL=(SIZE-2*MARGIN)/(N-1);
  const STAR=[[3,3],[3,11],[7,7],[11,3],[11,11]];

  const sideSel=document.getElementById('side-select');
  const statusEl=document.getElementById('status');
  const btnNew=document.getElementById('newgame');
  const btnUndo=document.getElementById('undo');

  // Weights for the evaluation function.
  // These can be tuned using the accompanying Python training script.
  const WEIGHTS = {
    win: 1e7,
    // Dynamic evaluation (evalMove)
    eval: {
      len: 89,
      liveFour: 84599,
      sleepFour: 6125,
      liveThree: 3766,
      sleepThree: 2682,
      center: 49,
      openFour: 9626,
      oppF3: 2000,
      fourThree: 67752
    },
    // Static evaluation (sideScore)
    static: {
      black: { len4: 1337, len: 193, fours: 5596, threes: 2738, sleepThree: 1699 },
      white: { len4: 2821, len: 119, fours: 4377, threes: 1530, sleepThree: 722 },
      oppThrees: 600
    }
  };

  let board, turn, history, winner, lastMove, humanPlays, aiPlays;

  function reset(){
    board=Array.from({length:N},()=>Array(N).fill(EMPTY));
    history=[]; winner=null; lastMove=null; turn=BLACK;
    humanPlays = sideSel.value==='human-black'?BLACK:WHITE;
    aiPlays = humanPlays===BLACK?WHITE:BLACK;
    draw();
    status(`New game. You are ${humanPlays===BLACK?'Black':'White'}. ${humanPlays===WHITE?'Computer (Black) to move.':'Your move…'}`);
    if (aiPlays===BLACK) aiMove();
  }
  function status(s){ statusEl.textContent=s; }
  function toXY(ev){
    const r=canvas.getBoundingClientRect();
    const x=(ev.clientX-r.left)*(canvas.width/r.width);
    const y=(ev.clientY-r.top)*(canvas.height/r.height);
    let c=Math.round((x-MARGIN)/CELL); let rr=Math.round((y-MARGIN)/CELL);
    if (rr<0||rr>=N||c<0||c>=N) return null;
    const px=MARGIN+c*CELL, py=MARGIN+rr*CELL;
    if (Math.hypot(px-x,py-y)>CELL*0.45) return null;
    return {r:rr,c};
  }
  canvas.addEventListener('click',e=>{ if(!winner){ const p=toXY(e); if(p) humanTry(p.r,p.c);} });
  btnNew.addEventListener('click', reset);
  btnUndo.addEventListener('click', undo);
  sideSel.addEventListener('change', reset);

  function draw(){
    ctx.clearRect(0,0,SIZE,SIZE);
    ctx.fillStyle='#f2e5c7'; ctx.fillRect(0,0,SIZE,SIZE);
    ctx.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--grid')||'#c9a878'; ctx.lineWidth=1;
    for(let i=0;i<N;i++){ const p=MARGIN+i*CELL; ctx.beginPath(); ctx.moveTo(MARGIN,p); ctx.lineTo(SIZE-MARGIN,p); ctx.stroke(); }
    for(let i=0;i<N;i++){ const p=MARGIN+i*CELL; ctx.beginPath(); ctx.moveTo(p,MARGIN); ctx.lineTo(p,SIZE-MARGIN); ctx.stroke(); }
    ctx.fillStyle=getComputedStyle(document.documentElement).getPropertyValue('--star')||'#a07b3a';
    STAR.forEach(([r,c])=>{ const x=MARGIN+c*CELL,y=MARGIN+r*CELL; ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); });
    for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c]) drawStone(r,c,board[r][c]);
    if(lastMove){ const {r,c}=lastMove; const x=MARGIN+c*CELL,y=MARGIN+r*CELL; ctx.strokeStyle='#3a86ff'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(x,y,CELL*0.22,0,Math.PI*2); ctx.stroke(); }
    if (winner){
      ctx.save(); ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,SIZE/2-24,SIZE,48);
      ctx.fillStyle='#fff'; ctx.font='700 22px system-ui, ui-sans-serif, -apple-system, Segoe UI, Roboto';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(`${winner===BLACK?'Black':'White'} wins!`, SIZE/2, SIZE/2); ctx.restore();
    }
  }
  function drawStone(r,c,color){
    const x=MARGIN+c*CELL,y=MARGIN+r*CELL,rad=CELL*0.32;
    const g=ctx.createRadialGradient(x-rad*0.3,y-rad*0.3,rad*0.2,x,y,rad);
    if(color===BLACK){ g.addColorStop(0,'#444'); g.addColorStop(1,'#111'); }
    else { g.addColorStop(0,'#fafafa'); g.addColorStop(1,'#d0d0d0'); }
    ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2); ctx.fillStyle=g; ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.stroke();
  }
  function humanTry(r,c){
    if (turn!==humanPlays) return;
    if (!placeIfLegal(humanPlays,r,c)){
      status(humanPlays===BLACK?'Illegal for Black or occupied; try another.':'Occupied; try another.');
      return;
    }
    if (!winner) aiMove();
  }
  function placeIfLegal(col,r,c){
    if (!inB(r,c) || board[r][c]!==EMPTY) return false;
    if (col===BLACK){
      const chk=forbiddenIfBlack(r,c);
      if (chk.forbidden) return false;
    }
    doMove(r,c,col);
    return true;
  }
  function doMove(r,c,col){
    board[r][c]=col; lastMove={r,c}; history.push({r,c,color:col});
    const len=maxLine(r,c,col);
    if (col===BLACK){ if (len===5) winner=BLACK; } else { if (len>=5) winner=WHITE; }
    turn=(col===BLACK)?WHITE:BLACK;
    draw();
    status(winner?`${winner===BLACK?'Black':'White'} wins!`:`${turn===humanPlays?'Your':'Computer'} move…`);
  }
  function undo(){
    if (!history.length || winner) return;
    const n=(history.length>=2)?2:1;
    for(let i=0;i<n;i++){ const m=history.pop(); board[m.r][m.c]=EMPTY; }
    winner=null; lastMove=history[history.length-1]||null; turn=BLACK;
    if(history.length){ const last=history[history.length-1]; turn=(last.color===BLACK)?WHITE:BLACK; }
    draw(); status('Undid.');
  }
  function inB(r,c){ return r>=0&&r<N&&c>=0&&c<N; }
  function maxLine(r,c,col){
    let best=1; const D=[[1,0],[0,1],[1,1],[1,-1]];
    for(const [dr,dc] of D){
      let cnt=1, rr=r+dr, cc=c+dc; while(inB(rr,cc)&&board[rr][cc]===col){cnt++; rr+=dr; cc+=dc;}
      rr=r-dr; cc=c-dc; while(inB(rr,cc)&&board[rr][cc]===col){cnt++; rr-=dr; cc-=dc;}
      if (cnt>best) best=cnt;
    }
    return best;
  }
  function forbiddenIfBlack(r,c){
    board[r][c]=BLACK;
    const len=maxLine(r,c,BLACK);
    if (len>5){ board[r][c]=EMPTY; return {forbidden:true, reason:'overline'}; }
    if (len===5){ board[r][c]=EMPTY; return {forbidden:false}; }
    const t=countThreatsAt(r,c,BLACK);
    board[r][c]=EMPTY;
    if (t.fours>=2) return {forbidden:true, reason:'double-four'};
    if (t.threes>=2) return {forbidden:true, reason:'double-three'};
    return {forbidden:false};
  }
  function lineStringAround(r,c,color,dr,dc){
    const me=color; const cells=[]; const coords=[];
    let rr=r-10*dr, cc=c-10*dc; while(!inB(rr,cc)){ rr+=dr; cc+=dc; }
    for(;inB(rr,cc); rr+=dr,cc+=dc){
      coords.push([rr,cc]);
      const v=board[rr][cc];
      if (rr===r && cc===c) cells.push('x');
      else if (v===EMPTY) cells.push('.');
      else if (v===me) cells.push('x');
      else cells.push('o');
    }
    const s=cells.join(''); const idx=coords.findIndex(p=>p[0]===r&&p[1]===c);
    return {s,idx,coords};
  }
  function countThreatsAt(r,c,color){
    const D=[[1,0],[0,1],[1,1],[1,-1]]; let fours=0, threes=0;
    let liveFour=0, sleepFour=0, liveThree=0, sleepThree=0;
    
    // Live Four: .xxxx. (Unstoppable)
    const R_L4 = /\.xxxx\./;
    // Sleep Four: xxxx., .xxxx, x.xxx, etc. (Forcing)
    const R_S4 = [/xxxx\./, /\.xxxx/, /x\.xxx/, /xxx\.x/, /xx\.xx/];
    // Live Three: .xxx., .x.xx. (Threat)
    const R_L3 = [/\.xxx\./, /\.x\.xx\./, /\.xx\.x\./];
    // Sleep Three: .xxx, xxx., .x.xx, etc. (Positional)
    const R_S3 = [/\.xxx/, /xxx\./, /\.x\.xx/, /xx\.x\./, /\.xx\.x/, /x\.xx\./];

    for(const [dr,dc] of D){
      const {s,idx}=lineStringAround(r,c,color,dr,dc);
      
      // Check Live Four
      let m = R_L4.exec(s);
      if(m && m.index<=idx && idx<m.index+m[0].length){ liveFour++; continue; }

      // Check Sleep Four
      let isS4=false;
      for(const re of R_S4){
        let m2=re.exec(s);
        if(m2 && m2.index<=idx && idx<m2.index+m2[0].length){ isS4=true; break; }
      }
      if(isS4){ sleepFour++; continue; }

      // Check Live Three
      let isL3=false;
      for(const re of R_L3){
        let m3=re.exec(s);
        if(m3 && m3.index<=idx && idx<m3.index+m3[0].length){ isL3=true; break; }
      }
      if(isL3){ liveThree++; continue; }

      // Check Sleep Three
      let isS3=false;
      for(const re of R_S3){
        let m4=re.exec(s);
        if(m4 && m4.index<=idx && idx<m4.index+m4[0].length){ isS3=true; break; }
      }
      if(isS3) sleepThree++;
    }
    return {liveFour, sleepFour, liveThree, sleepThree};
  }
  function hasNeighbor(r,c,d){
    for(let dr=-d;dr<=d;dr++) for(let dc=-d;dc<=d;dc++){
      if(!dr && !dc) continue;
      const rr=r+dr, cc=c+dc;
      if(inB(rr,cc) && board[rr][cc]!==EMPTY) return true;
    }
    return false;
  }
  function stonesPlaced(){ for(let r=0;r<N;r++) for(let c=0;c<N;c++) if(board[r][c]!==EMPTY) return true; return false; }
  function currentFreeThreeFor(color){
    const moves=[]; const seen=new Set();
    const re=/\.xxx\.|\.xx\.x\.|\.x\.xx\./g;
    function scan(r0,c0,dr,dc){
      let r=r0,c=c0; const coords=[], chars=[];
      while(inB(r,c)){ coords.push([r,c]); const v=board[r][c]; chars.push(v===0?'.':(v===color?'x':'o')); r+=dr; c+=dc; }
      const s=chars.join(''); re.lastIndex=0; let m;
      while((m=re.exec(s))){
        const start=m.index, pat=m[0];
        if(pat===' .xx.x. '.trim()){ const [rr,cc]=coords[start+3]; const key=rr+','+cc; if(board[rr][cc]===EMPTY && !seen.has(key)){ seen.add(key); moves.push({r:rr,c:cc,kind:'gap'}); } }
        else if(pat===' .x.xx. '.trim()){ const [rr,cc]=coords[start+2]; const key=rr+','+cc; if(board[rr][cc]===EMPTY && !seen.has(key)){ seen.add(key); moves.push({r:rr,c:cc,kind:'gap'}); } }
        else if(pat===' .xxx. '.trim()){ const ends=[coords[start],coords[start+4]]; for(const [rr,cc] of ends){ const key=rr+','+cc; if(board[rr][cc]===EMPTY && !seen.has(key)){ seen.add(key); moves.push({r:rr,c:cc,kind:'end'}); } } }
      }
    }
    for(let r=0;r<N;r++) scan(r,0,0,1);
    for(let c=0;c<N;c++) scan(0,c,1,0);
    for(let k=0;k<N;k++) scan(k,0,1,1);
    for(let k=1;k<N;k++) scan(0,k,1,1);
    for(let k=0;k<N;k++) scan(k,0,-1,1);
    for(let k=1;k<N;k++) scan(N-1,k,-1,1);
    return moves;
  }
  function createsOpenFour(color,r,c){
    board[r][c]=color;
    const D=[[1,0],[0,1],[1,1],[1,-1]]; let ok=false;
    for(const [dr,dc] of D){
      const {s}=lineStringAround(r,c,color,dr,dc);
      if (/\.(xxxx)\./.test(s)) { ok=true; break; }
    }
    board[r][c]=EMPTY; return ok;
  }
  function openFourSquaresFor(color){
    const out=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(board[r][c]!==EMPTY) continue;
      if(color===BLACK && forbiddenIfBlack(r,c).forbidden) continue;
      if (createsOpenFour(color,r,c)) out.push({r,c});
    }
    return out;
  }
  function fourThreeSquaresFor(color){
    const pts=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(board[r][c]!==EMPTY) continue;
      if(color===BLACK && forbiddenIfBlack(r,c).forbidden) continue;
      board[r][c]=color;
      const o4 = openFourSquaresFor(color);
      if (o4.length){
        const oSet=new Set(o4.map(p=>p.r+','+p.c));
        const f3 = currentFreeThreeFor(color).some(x=>!oSet.has(x.r+','+x.c));
        if (f3) pts.push({r,c});
      }
      board[r][c]=EMPTY;
    }
    return pts;
  }
  function opponent43Squares(opp){ return fourThreeSquaresFor(opp); }
  function evalMove(color,r,c){
    if(!inB(r,c) || board[r][c]!==EMPTY) return -1e18;
    board[r][c]=color;
    const len=maxLine(r,c,color);
    const {liveFour, sleepFour, liveThree, sleepThree} = countThreatsAt(r,c,color);
    const opp=(color===BLACK)?WHITE:BLACK;
    let sc=0;
    if ((color===BLACK && len===5) || (color===WHITE && len>=5)) sc+=WEIGHTS.win;
    
    sc += WEIGHTS.eval.len*len + WEIGHTS.eval.liveFour*liveFour + WEIGHTS.eval.sleepFour*sleepFour + WEIGHTS.eval.liveThree*liveThree + WEIGHTS.eval.sleepThree*sleepThree;
    
    // Four-Three: A live three and a four (live or sleep)
    if ((liveFour + sleepFour) > 0 && liveThree > 0) sc += WEIGHTS.eval.fourThree;
    
    const dx=Math.abs(c-7), dy=Math.abs(r-7); sc += WEIGHTS.eval.center*(7-Math.max(dx,dy));
    if (createsOpenFour(color,r,c)) sc += WEIGHTS.eval.openFour;
    const oppF3 = currentFreeThreeFor(opp).length;
    sc -= WEIGHTS.eval.oppF3*oppF3;
    board[r][c]=EMPTY;
    return sc;
  }
  function candidateMoves(color){
    if(!stonesPlaced()) return [{r:7,c:7}];
    const near=[]; const seen=new Set();
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(board[r][c]===EMPTY && hasNeighbor(r,c,3)){
        const k=r+','+c; if(!seen.has(k)){ seen.add(k); near.push({r,c}); }
      }
    }
    const scored = near.map(m=>({m,s:evalMove(color,m.r,m.c)}))
                       .sort((a,b)=>b.s-a.s)
                       .slice(0,64)
                       .map(x=>x.m);
    return scored.length?scored:[{r:7,c:7}];
  }
  function safeLegal(color,r,c){ return board[r][c]===EMPTY && (color===WHITE || !forbiddenIfBlack(r,c).forbidden); }
  function isWinningPlacement(color,r,c){
    if(board[r][c]!==EMPTY) return false;
    board[r][c]=color; const len=maxLine(r,c,color);
    let win=(color===BLACK)?(len===5):(len>=5);
    if(color===BLACK && !win){ const chk=forbiddenIfBlack(r,c); if(chk.forbidden) win=false; }
    board[r][c]=EMPTY; return win;
  }
  function immediateWinningMovesAll(color){
    const out=[];
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(board[r][c]!==EMPTY) continue;
      if(color===BLACK && forbiddenIfBlack(r,c).forbidden) continue;
      if(isWinningPlacement(color,r,c)) out.push({r,c});
    }
    return out;
  }
  const Z=(function(){
    const rnd=()=> (Math.random()*2**32)>>>0;
    const table=Array.from({length:N},()=>Array.from({length:N},()=>[rnd(),rnd(),rnd()]));
    function key(){ let h=2166136261>>>0; for(let r=0;r<N;r++) for(let c=0;c<N;c++){ h ^= table[r][c][board[r][c]]; h = Math.imul(h,16777619)>>>0; } return h>>>0; }
    return {key};
  })();
  const TT=new Map();
  const KILLERS=Array.from({length:64},()=>[]);
  const HIST=new Map();
  function addKiller(d,m){ const a=KILLERS[d]; if(!a.length || a[0].r!==m.r || a[0].c!==m.c){ a.unshift(m); if(a.length>2)a.pop(); } }
  function bumpHist(m,d){ const k=m.r+','+m.c; HIST.set(k,(HIST.get(k)||0)+d*d); }
  function orderMoves(color,moves,best){
    const opp=(color===BLACK)?WHITE:BLACK; const keyBest=best?best.r+','+best.c:null;
    return moves.map(m=>{
      let s=evalMove(color,m.r,m.c);
      if(keyBest===m.r+','+m.c) s+=5e5;
      const isK=KILLERS.some(a=>a.some(k=>k.r===m.r && k.c===m.c)); if(isK) s+=4e5;
      s+=(HIST.get(m.r+','+m.c)||0);
      if(isWinningPlacement(opp,m.r,m.c)) s+=3e5;
      if(createsOpenFour(color,m.r,m.c)) s+=2e5;
      return {m,s};
    }).sort((a,b)=>b.s-a.s).map(x=>x.m);
  }
  function staticEval(pov){
    const sb=sideScore(BLACK), sw=sideScore(WHITE), base=sb-sw; 
    return (pov===BLACK?1:-1)*base;
  }
  function sideScore(color){
    let s=0; const opp=(color===BLACK)?WHITE:BLACK;
    for(let r=0;r<N;r++) for(let c=0;c<N;c++){
      if(board[r][c]===color){
        const len=maxLine(r,c,color);
        const {liveFour, sleepFour, liveThree, sleepThree} = countThreatsAt(r,c,color);
        const fours = liveFour + sleepFour;
        if(color===BLACK){ s+=(len>=4?WEIGHTS.static.black.len4:0)+WEIGHTS.static.black.len*len+WEIGHTS.static.black.fours*fours+WEIGHTS.static.black.threes*liveThree+WEIGHTS.static.black.sleepThree*sleepThree; }
        else { s+=(len>=4?WEIGHTS.static.white.len4:0)+WEIGHTS.static.white.len*len+WEIGHTS.static.white.fours*fours+WEIGHTS.static.white.threes*liveThree+WEIGHTS.static.white.sleepThree*sleepThree; }
      }
      if(board[r][c]===opp){ const t=countThreatsAt(r,c,opp); s+=WEIGHTS.static.oppThrees*t.liveThree; }
    }
    return s;
  }
  function quiescence(color, alpha, beta, depthQ, deadline){
    if (performance.now()>deadline) return {score:0, timeout:true};
    const opp=(color===BLACK)?WHITE:BLACK;
    let stand=staticEval(color);
    if (stand>=beta) return {score:beta};
    if (stand>alpha) alpha=stand;
    const moves=[];
    for(const m of immediateWinningMovesAll(color)) moves.push(m);
    for(const m of immediateWinningMovesAll(opp)) moves.push(m);
    for(const m of openFourSquaresFor(color)) moves.push(m);
    for(const m of openFourSquaresFor(opp)) moves.push(m);
    for(const m of currentFreeThreeFor(color)) moves.push(m);
    for(const m of currentFreeThreeFor(opp)) moves.push(m);
    const ordered=orderMoves(color, moves.filter(m=>safeLegal(color,m.r,m.c)), null);
    for(const m of ordered){
      board[m.r][m.c]=color;
      const r=quiescence(opp, -beta, -alpha, depthQ-1, deadline);
      board[m.r][m.c]=EMPTY;
      if (r.timeout) return {score:0, timeout:true};
      const val=-r.score;
      if (val>=beta) return {score:beta};
      if (val>alpha) alpha=val;
      if (depthQ<=0) break;
    }
    return {score:alpha};
  }
  function search(color,depth,alpha,beta,last,deadline, ply){
    if (performance.now()>deadline) return {score:0, move:null, timeout:true};
    const opp=(color===BLACK)?WHITE:BLACK;
    if(last){
      const len=maxLine(last.r,last.c,last.color);
      const lastWon=(last.color===BLACK)?(len===5):(len>=5);
      if(lastWon) return {score:-999999+depth, move:null};
    }
    if (depth<=0){
      const q=quiescence(color, alpha, beta, 4, deadline);
      return {score:q.score, move:null, timeout:q.timeout};
    }
    const key=(Z.key()*33+color+depth)>>>0; const hit=TT.get(key);
    if(hit && hit.depth>=depth){
      if(hit.flag==='EXACT') return {score:hit.score, move:hit.best};
      if(hit.flag==='LOWER' && hit.score>alpha) alpha=hit.score;
      if(hit.flag==='UPPER' && hit.score<beta)  beta=hit.score;
      if(alpha>=beta) return {score:hit.score, move:hit.best};
    }
    let cands=candidateMoves(color).filter(m=>safeLegal(color,m.r,m.c));
    if(!cands.length) return {score:0, move:null};
    const winners=[], others=[];
    for(const m of cands){ if(isWinningPlacement(color,m.r,m.c)) winners.push(m); else others.push(m); }
    let ordered=orderMoves(color, others, hit?.best); cands=winners.concat(ordered);
    let best=null; let nodeType='UPPER'; let first=true;
    for(let i=0;i<cands.length;i++){
      const m=cands[i];
      board[m.r][m.c]=color;
      let d=depth-1;
      const forcing=createsOpenFour(color,m.r,m.c);
      const blocks=isWinningPlacement(opp,m.r,m.c);
      const late=(i>10)&&!forcing&&!blocks&&depth>=3;
      if(late) d=Math.max(0,d-2);
      let score;
      if (first){
        const r=search(opp,d,-beta,-alpha,{r:m.r,c:m.c,color},deadline, ply+1);
        if(r.timeout){ board[m.r][m.c]=EMPTY; return {score:0, move:best, timeout:true}; }
        score=-r.score; first=false;
      } else {
        let r=search(opp,d,-alpha-1,-alpha,{r:m.r,c:m.c,color},deadline, ply+1);
        if(r.timeout){ board[m.r][m.c]=EMPTY; return {score:0, move:best, timeout:true}; }
        score=-r.score;
        if(score>alpha && score<beta){
          r=search(opp,d,-beta,-score,{r:m.r,c:m.c,color},deadline, ply+1);
          if(r.timeout){ board[m.r][m.c]=EMPTY; return {score:0, move:best, timeout:true}; }
          score=-r.score;
        }
      }
      board[m.r][m.c]=EMPTY;
      if(score>alpha){ alpha=score; best=m; nodeType='EXACT'; }
      if(alpha>=beta){ nodeType='LOWER'; addKiller(depth,m); bumpHist(m,depth); break; }
    }
    TT.set(key,{depth,score:alpha,best,flag:nodeType});
    return {score:alpha, move:best};
  }
  function tacticalMove(me){
    const opp=(me===BLACK)?WHITE:BLACK;
    const myW=immediateWinningMovesAll(me)[0]; if (myW) return myW;
    const oppW=immediateWinningMovesAll(opp)[0]; if (oppW && safeLegal(me,oppW.r,oppW.c)) return oppW;
    const oppO4=openFourSquaresFor(opp).filter(m=>safeLegal(me,m.r,m.c));
    if (oppO4.length) return oppO4.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    const opp43=opponent43Squares(opp).filter(m=>safeLegal(me,m.r,m.c));
    if (opp43.length) return opp43.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    const oppF3=currentFreeThreeFor(opp).filter(x=>safeLegal(me,x.r,x.c));
    if (oppF3.length) return oppF3.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    const myO4=openFourSquaresFor(me).filter(m=>safeLegal(me,m.r,m.c));
    if (myO4.length) return myO4.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    const my43=fourThreeSquaresFor(me).filter(m=>safeLegal(me,m.r,m.c));
    if (my43.length) return my43.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    const myF3=currentFreeThreeFor(me).filter(x=>safeLegal(me,x.r,x.c));
    if (myF3.length) return myF3.sort((a,b)=>evalMove(me,b.r,b.c)-evalMove(me,a.r,a.c))[0];
    return null;
  }
  function aiMove(){
    if (winner || turn!==aiPlays) return;
    status('Computer thinking…');
    const me=aiPlays;
    const budget=6000;
    const watchdog=setTimeout(()=>{
      const cands=candidateMoves(me).filter(m=>safeLegal(me,m.r,m.c));
      for(const m of cands){ if(placeIfLegal(me,m.r,m.c)) return; }
      status('AI passes (no legal moves).'); turn=humanPlays;
    }, budget + 1500);
    setTimeout(()=>{
      try{
        const t = tacticalMove(me);
        if (t && placeIfLegal(me,t.r,t.c)){ clearTimeout(watchdog); return; }
        let best=null, lastScore=0, deadline=performance.now()+budget;
        for(let depth=6; depth<=18; depth++){
          let alpha=lastScore-200, beta=lastScore+200;
          let res=search(me, depth, alpha, beta, null, deadline, 0);
          if(res.timeout) break;
          if (res.score<=alpha){
            res=search(me, depth, -1e18, beta, null, deadline, 0);
            if(res.timeout) break;
          } else if (res.score>=beta){
            res=search(me, depth, alpha, 1e18, null, deadline, 0);
            if(res.timeout) break;
          }
          if (res.move){ best=res.move; lastScore=res.score; }
          if (performance.now()>deadline) break;
        }
        clearTimeout(watchdog);
        if (best && placeIfLegal(me,best.r,best.c)) return;
        const cands=candidateMoves(me).filter(m=>safeLegal(me,m.r,m.c));
        for(const m of cands){ if(placeIfLegal(me,m.r,m.c)) return; }
        status('AI passes (no legal moves).'); turn=humanPlays;
      }catch(e){
        console.error('AI error',e);
        clearTimeout(watchdog);
        const cands=candidateMoves(me).filter(m=>safeLegal(me,m.r,m.c));
        for(const m of cands){ if(placeIfLegal(me,m.r,m.c)) return; }
        status('AI error; skipping move.'); turn=humanPlays;
      }
    },10);
  }
  reset();
})();
</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>