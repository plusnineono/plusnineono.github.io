<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Play Renju vs Computer – Tasuku Ono</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-35775312f623334fe0cde8345bd217f4.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-ZBV5W7QD1W"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-ZBV5W7QD1W', { 'anonymize_ip': true});
</script>
<style>html{ scroll-behavior: smooth; }</style>


<link rel="stylesheet" href="styles.css">
<meta name="twitter:title" content="Play Renju vs Computer – Tasuku Ono">
<meta name="twitter:creator" content="@PlusNineOnZero">
<meta name="twitter:card" content="summary">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Tasuku Ono</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./natural-languages.html"> 
<span class="menu-text">Natural Languages</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./renju.html" aria-current="page"> 
<span class="menu-text">Renju</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">Play Renju vs Computer</li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Play Renju vs Computer</h1>
</div>



<div class="quarto-title-meta column-page-right">

    
  
    
  </div>
  


</header>


<div class="controls">
  <div class="row">
    <label>Play as:</label>
    <select id="side-select">
      <option value="human-black">Black (forbidden moves apply)</option>
      <option value="human-white" selected="">White</option>
    </select>
    <label class="sp">AI level:</label>
    <select id="level-select">
      <option value="0" selected="">Quick</option>
      <option value="1">Solver</option>
    </select>
    <button id="newgame">New Game</button>
    <button id="undo">Undo</button>
    <button id="aigo">AI Move</button>
  </div>
  <div id="status">Loading…</div>
</div>

<div class="board-wrap">
  <canvas id="board" width="640" height="640" aria-label="Renju board" role="img"></canvas>
</div>

<div class="help">
  <details>
    <summary>Rules this page enforces</summary>
    <ul>
      <li>Board size: 15×15. Exactly 5-in-a-row wins for Black; ≥5 wins for White. Black may not win by overline (6+).</li>
      <li>Black forbidden moves: overline, double-three, double-four. If a legal move makes exactly five, Black wins even if it simultaneously forms threes/fours.</li>
      <li>Opening rules like Swap / Soosõrv are <em>not</em> enforced here.</li>
    </ul>
  </details>
</div>

<style>
:root {
  --bg: #fafaf8; --grid: #c9a878; --star: #a07b3a; --black: #111; --white: #fafafa;
  --accent: #0b6cff; --warn: #d95832; --ok: #0a7a27;
}
body { background: var(--bg); }
.board-wrap { display:flex; justify-content:center; margin: 8px 0 24px; }
.controls { max-width: 960px; margin: 0 auto 8px; padding: 8px 12px; }
.controls .row { display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
.controls label { font-weight:600; }
.controls .sp { margin-left: 6px; }
#status { margin-top: 6px; font-weight:600; }
button, select { border:1px solid #ddd; border-radius:10px; padding:6px 10px; background:#fff; cursor:pointer; }
button:hover { box-shadow: 0 1px 8px rgba(0,0,0,0.06); }
.help { max-width:960px; margin: 0 auto 24px; color:#444; }
summary { cursor:pointer; }
</style>

<script>
(function(){
  const N = 15; // board size
  const EMPTY=0, BLACK=1, WHITE=2;
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  const MARGIN = 32; // px
  const SIZE = canvas.width; // assume square
  const CELL = (SIZE - 2*MARGIN)/(N-1);
  const STAR_PTS = [[3,3],[3,11],[7,7],[11,3],[11,11]];
  const sideSelect = document.getElementById('side-select');
  const levelSelect = document.getElementById('level-select');
  const statusEl = document.getElementById('status');
  const btnNew = document.getElementById('newgame');
  const btnUndo = document.getElementById('undo');
  const btnAi = document.getElementById('aigo');

  let board, turn, history, winner, lastMove, humanPlays, aiPlays;

  function reset(){
    board = Array.from({length:N}, ()=>Array(N).fill(EMPTY));
    history = [];
    winner = null; lastMove = null;
    turn = BLACK; // black starts
    humanPlays = sideSelect.value === 'human-black' ? BLACK : WHITE;
    aiPlays = humanPlays===BLACK? WHITE : BLACK;
    draw();
    status(`New game. You are ${humanPlays===BLACK?'Black':'White'}. ${humanPlays===WHITE?'Computer (Black) to move.':'Your move.'}`);
    if (aiPlays===BLACK) aiMove();
  }

  function toXY(ev) {
    const rect = canvas.getBoundingClientRect();
    const x = (ev.clientX - rect.left) * (canvas.width/rect.width);
    const y = (ev.clientY - rect.top) * (canvas.height/rect.height);
    // snap to nearest intersection
    let c = Math.round((x - MARGIN)/CELL);
    let r = Math.round((y - MARGIN)/CELL);
    if (r<0||r>=N||c<0||c>=N) return null;
    const px = MARGIN + c*CELL, py = MARGIN + r*CELL;
    const dist = Math.hypot(px-x, py-y);
    if (dist>CELL*0.45) return null; // must click close
    return {r, c};
  }

  function draw(){
    // bg
    ctx.clearRect(0,0,SIZE,SIZE);
    ctx.fillStyle = '#f2e5c7';
    ctx.fillRect(0,0,SIZE,SIZE);
    // grid
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid')||'#c9a878';
    ctx.lineWidth = 1;
    for (let i=0;i<N;i++){
      const p = MARGIN + i*CELL;
      ctx.beginPath(); ctx.moveTo(MARGIN, p); ctx.lineTo(SIZE-MARGIN, p); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(p, MARGIN); ctx.lineTo(p, SIZE-MARGIN); ctx.stroke();
    }
    // star points
    ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--star')||'#a07b3a';
    STAR_PTS.forEach(([r,c])=>{
      const x = MARGIN + c*CELL, y = MARGIN + r*CELL;
      ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
    });
    // stones
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){
      if (!board[r][c]) continue; const color = board[r][c];
      drawStone(r,c,color);
    }
    // last move marker
    if (lastMove){
      const {r,c} = lastMove; const x=MARGIN+c*CELL, y=MARGIN+r*CELL;
      ctx.strokeStyle = '#3a86ff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(x,y, CELL*0.22, 0, Math.PI*2); ctx.stroke();
    }
    // winner banner
    if (winner){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0,SIZE/2-24,SIZE,48);
      ctx.fillStyle = '#fff'; ctx.font = '700 22px system-ui, ui-sans-serif, -apple-system, Segoe UI, Roboto';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(`${winner===BLACK?'Black':'White'} wins!`, SIZE/2, SIZE/2);
      ctx.restore();
    }
  }

  function drawStone(r,c,color){
    const x = MARGIN + c*CELL, y = MARGIN + r*CELL, rad = CELL*0.32;
    const grad = ctx.createRadialGradient(x-rad*0.3,y-rad*0.3,rad*0.2, x,y,rad);
    if (color===BLACK){ grad.addColorStop(0,'#444'); grad.addColorStop(1,'#111'); }
    else { grad.addColorStop(0,'#fafafa'); grad.addColorStop(1,'#d0d0d0'); }
    ctx.beginPath(); ctx.arc(x,y,rad,0,Math.PI*2);
    ctx.fillStyle = grad; ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.stroke();
  }

  function status(msg){ statusEl.textContent = msg; }

  function onClick(ev){ if (winner) return; const pos = toXY(ev); if (!pos) return; humanTryMove(pos.r, pos.c); }

  function humanTryMove(r,c){
    if (board[r][c]!==EMPTY) return;
    if (turn !== humanPlays) return;
    const forb = (humanPlays===BLACK) ? forbiddenIfBlackMove(r,c) : null;
    if (forb && forb.forbidden){ status(`Illegal for Black: ${forb.reason}. Try another move.`); return; }
    doMove(r,c,humanPlays);
    if (!winner) aiMove();
  }

  function doMove(r,c,color){
    board[r][c] = color; lastMove = {r,c}; history.push({r,c,color});
    // win check
    const lineLen = maxLineThrough(r,c,color);
    if (color===BLACK){
      if (lineLen===5) { winner = BLACK; }
    } else {
      if (lineLen>=5) { winner = WHITE; }
    }
    turn = (color===BLACK) ? WHITE : BLACK;
    draw();
    status(winner ? `${winner===BLACK?'Black':'White'} wins!` : `${turn===humanPlays? 'Your' : 'Computer'} move…`);
  }

  function undo(){ if (!history.length || winner) return; const steps = (history.length>=2)?2:1; for (let i=0;i<steps;i++){ const m=history.pop(); board[m.r][m.c]=EMPTY; }
    winner=null; lastMove=history[history.length-1]||null; turn=BLACK; if (history.length){ const last=history[history.length-1]; turn = (last.color===BLACK)?WHITE:BLACK; }
    draw(); status('Undid.'); }

  function maxLineThrough(r,c,color){
    let best=1; const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    for (const [dr,dc] of dirs){
      let cnt=1; let rr=r+dr, cc=c+dc; while(inB(rr,cc)&&board[rr][cc]===color){cnt++; rr+=dr; cc+=dc;}
      rr=r-dr; cc=c-dc; while(inB(rr,cc)&&board[rr][cc]===color){cnt++; rr-=dr; cc-=dc;}
      if (cnt>best) best=cnt;
    }
    return best;
  }

  function inB(r,c){ return r>=0&&r<N&&c>=0&&c<N; }

  // ===== Forbidden move detection (approximate but strong) =====
  function forbiddenIfBlackMove(r,c){
    // simulate
    board[r][c]=BLACK;
    const len = maxLineThrough(r,c,BLACK);
    if (len>5){ board[r][c]=EMPTY; return {forbidden:true, reason:'overline (6+ in a row)'}; }
    if (len===5){ board[r][c]=EMPTY; return {forbidden:false, reason:null}; }
    // count double-fours and double-threes created involving the placed stone
    const {fours, threes} = countThreatsAt(r,c,BLACK);
    board[r][c]=EMPTY;
    if (fours>=2) return {forbidden:true, reason:'double-four'};
    if (threes>=2) return {forbidden:true, reason:'double-three'};
    return {forbidden:false, reason:null};
  }

  function lineStringAround(r,c,color, dr,dc){
    // build a 1D string with ., x(player), o(opponent) around (r,c)
    const me = color, opp = (color===BLACK)?WHITE:BLACK;
    let cells=[]; let coords=[];
    // go back up to 10
    let rr=r-10*dr, cc=c-10*dc; while(!inB(rr,cc)){ rr+=dr; cc+=dc; }
    for (; inB(rr,cc); rr+=dr,cc+=dc){
      coords.push([rr,cc]);
      const v = board[rr][cc];
      if (rr===r && cc===c) { cells.push('x'); }
      else if (v===EMPTY) cells.push('.');
      else if (v===me) cells.push('x');
      else cells.push('o');
    }
    const s = cells.join('');
    const idx = coords.findIndex(p=>p[0]===r&&p[1]===c);
    return {s, idx};
  }

  function countThreatsAt(r,c,color){
    const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    let fours=0, threes=0;
    for (const [dr,dc] of dirs){
      const {s, idx} = lineStringAround(r,c,color, dr,dc);
      // FOUR patterns (any single-move 5): xxxx., .xxxx, xxx.x, x.xxx, xx.xx, .xxxx.
      const fourPats = [/xxxx\./g,/\.xxxx/g,/xxx\.x/g,/x\.xxx/g,/xx\.xx/g,/\.xxxx\./g];
      let hasFour=false; for (const re of fourPats){ let m; while((m=re.exec(s))){ if (m.index<=idx && idx < m.index+m[0].length){ hasFour=true; break; } } if (hasFour) break; }
      if (hasFour) fours += 1;
      // FREE THREE patterns: .xxx., .xx.x., .x.xx.
      const threePats = [/\.xxx\./g,/\.xx\.x\./g,/\.x\.xx\./g];
      let local3=0; for (const re of threePats){ let m; while((m=re.exec(s))){ if (m.index<=idx && idx < m.index+m[0].length) local3++; } }
      threes += local3;
    }
    return {fours, threes};
  }

  // ===== AI =====
  function aiMove(){
    if (winner || turn!==aiPlays) return;
    const mode = parseInt(levelSelect.value,10)||0; // 0: Quick, 1: Solver
    const thinkMs = (mode===0)? 350 : 1500;
    status('Computer thinking…');
    setTimeout(()=>{
      const me = aiPlays, opp = (me===BLACK)?WHITE:BLACK;

      // 0) Must block opponent's immediate win
      const oppWins = immediateWinningMoves(opp);
      if (oppWins.length){
        const blockers = candidateMoves(me).filter(m=> oppWins.some(w=>w.r===m.r && w.c===m.c))
          .filter(m=> me!==BLACK || !forbiddenIfBlackMove(m.r,m.c).forbidden);
        if (blockers.length){ const best = pickBest(me, blockers); doMove(best.r, best.c, me); return; }
      }

      // 1) Solver mode: try VCF winning line first
      if (mode===1){
        const vcf = findVCFMove(me, /*maxDepth*/8, /*ms*/ Math.floor(thinkMs*0.6));
        if (vcf && vcf.move){ doMove(vcf.move.r, vcf.move.c, me); return; }
      }

      // 2) Strong defence vs opponent \"free threes\": preempt threatening squares
      const critical = criticalThreeSquares(opp);
      if (critical.length){
        const blocks = candidateMoves(me).filter(m=> critical.some(p=>p.r===m.r && p.c===m.c))
          .filter(m=> me!==BLACK || !forbiddenIfBlackMove(m.r,m.c).forbidden);
        if (blocks.length){ const best = pickBest(me, blocks); doMove(best.r, best.c, me); return; }
      }

      // 3) Fallback: timed negamax
      const move = bestMoveTimed(me, thinkMs);
      if (!move){ status('AI passes (no legal moves).'); turn = humanPlays; return; }
      doMove(move.r, move.c, me);
    }, 10);
  }

  function pickBest(color, list){
    let best=list[0], bestS=-1e18; for (const m of list){ const s=evalMove(color,m.r,m.c); if (s>bestS){best=m; bestS=s;} } return best;
  }

  function bestMoveTimed(color, ms){
    const start = performance.now();
    const deadline = start + ms;
    let best=null, bestScore=-1e18;
    const winNow = immediateWinningMoves(color)[0];
    if (winNow) return winNow;
    for (let depth=2; depth<=9; depth++){
      const res = negamax(color, depth, -1e18, 1e18, null, deadline);
      if (res.timedOut) break;
      if (res.move){ best = res.move; bestScore = res.score; }
      if (performance.now()>deadline) break;
    }
    return best;
  }

  function negamax(color, depth, alpha, beta, last, deadline){
    if (performance.now()>deadline) return {score:0, move:null, timedOut:true};
    const opp = (color===BLACK)?WHITE:BLACK;

    if (last){
      const len = maxLineThrough(last.r,last.c,last.color);
      const lastWon = (last.color===BLACK) ? (len===5) : (len>=5);
      if (lastWon) return {score: -999999 + depth, move:null, timedOut:false};
    }
    if (depth===0){ return {score: staticEval(color), move:null, timedOut:false}; }

    let cands = candidateMoves(color);
    if (color===BLACK) cands = cands.filter(m=>!forbiddenIfBlackMove(m.r,m.c).forbidden);
    if (!cands.length) return {score: 0, move:null, timedOut:false};

    const winners = [] , others=[];
    for (const m of cands){ if (isWinningPlacement(color,m.r,m.c)) winners.push(m); else others.push(m); }
    others.sort((a,b)=> evalMove(color,b.r,b.c) - evalMove(color,a.r,a.c));
    cands = winners.concat(others);

    let best=null;
    for (const m of cands){
      board[m.r][m.c]=color;
      const res = negamax(opp, depth-1, -beta, -alpha, {r:m.r,c:m.c,color}, deadline);
      board[m.r][m.c]=EMPTY;
      if (res.timedOut) return {score:0, move:best, timedOut:true};
      const val = -res.score;
      if (val>alpha){ alpha=val; best=m; }
      if (alpha>=beta) break;
    }
    return {score: alpha, move: best, timedOut:false};
  }

  function staticEval(pov){
    const sb = sideScore(BLACK);
    const sw = sideScore(WHITE);
    const base = sb - sw;
    return (pov===BLACK? 1 : -1) * base;
  }

  function sideScore(color){
    let s=0;
    const opp = (color===BLACK)?WHITE:BLACK;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++){
      if (board[r][c]===color){
        const len = maxLineThrough(r,c,color);
        const {fours, threes} = countThreatsAt(r,c,color);
        if (color===BLACK){
          s += (len>=4? 1400: 0) + 120*len;
          s += 5500*fours + 1500*threes;
        } else {
          s += (len>=4? 1600: 0) + 130*len;
          s += 5000*fours + 1400*threes;
        }
      }
      if (board[r][c]===opp){
        const {threes} = countThreatsAt(r,c,opp);
        s += 400 * threes; // favour positions that reduce opp free threes
      }
    }
    return s;
  }

  function immediateWinningMoves(color){
    const out=[]; const cands = candidateMoves(color);
    for (const m of cands){
      if (color===BLACK && forbiddenIfBlackMove(m.r,m.c).forbidden) continue;
      if (isWinningPlacement(color, m.r, m.c)) out.push(m);
    }
    return out;
  }

  // Squares where opponent would create a strong free three on their move.
  function criticalThreeSquares(opp){
    const res=[]; const set=new Set();
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]===EMPTY){
      if (opp===BLACK && forbiddenIfBlackMove(r,c).forbidden) continue; // black illegal threat doesn't count
      board[r][c]=opp;
      const {threes} = countThreatsAt(r,c,opp);
      const winsNext = immediateWinningMoves(opp).length; // after they make a three, do they have an immediate winning point?\n
      board[r][c]=EMPTY;
      if (threes>0 || winsNext>0){ const k=r+','+c; if(!set.has(k)){ set.add(k); res.push({r,c}); } }
    }
    return res;
  }

  // ---- VCF threat-space search (Victory by Continuous Four) ----
  function findVCFMove(attacker, maxDepth, ms){
    const deadline = performance.now() + (ms||800);
    const opp = (attacker===BLACK)?WHITE:BLACK;

    const winNow = immediateWinningMoves(attacker);
    if (winNow.length) return {move: winNow[0], line:[winNow[0]]};

    function attackMoves(){
      const cands = candidateMoves(attacker);
      const good=[];
      for(const m of cands){
        if (attacker===BLACK && forbiddenIfBlackMove(m.r,m.c).forbidden) continue;
        board[m.r][m.c]=attacker;
        const wins = immediateWinningMoves(attacker);
        board[m.r][m.c]=EMPTY;
        if (wins.length>0) good.push({m, score: wins.length*10000 + evalMove(attacker,m.r,m.c)});
      }
      good.sort((a,b)=>b.score-a.score);
      return good.map(g=>g.m);
    }

    function dfs(depth){
      if (performance.now()>deadline) return null;
      if (depth===0) return null;
      const moves = attackMoves();
      for (const m of moves){
        board[m.r][m.c]=attacker;
        const wins = immediateWinningMoves(attacker);
        if (wins.length>=2){ board[m.r][m.c]=EMPTY; return [m]; }
        if (wins.length===0){ board[m.r][m.c]=EMPTY; continue; }
        const block = wins[0];
        if (opp===BLACK && forbiddenIfBlackMove(block.r,block.c).forbidden){ board[m.r][m.c]=EMPTY; return [m]; }
        board[block.r][block.c]=opp;
        const cont = dfs(depth-1);
        board[block.r][block.c]=EMPTY;
        board[m.r][m.c]=EMPTY;
        if (cont){ cont.unshift(m); return cont; }
      }
      return null;
    }

    for (let d=1; d<=maxDepth; d++){
      const line = dfs(d);
      if (line) return {move: line[0], line};
      if (performance.now()>deadline) break;
    }
    return null;
  }

  function evalMove(color, r, c){
    const opp = (color===BLACK)?WHITE:BLACK;
    if (board[r][c]!==EMPTY) return -1e9;
    if (color===BLACK){ const chk = forbiddenIfBlackMove(r,c); if (chk.forbidden) return -1e9; }

    board[r][c]=color;
    const len = maxLineThrough(r,c,color);
    const {fours, threes} = countThreatsAt(r,c,color);

    let oppThreat = 0;
    const oppCands = candidateMoves(opp);
    for (const m of oppCands){
      if (opp===BLACK && forbiddenIfBlackMove(m.r,m.c).forbidden) continue;
      board[m.r][m.c]=opp; const l = maxLineThrough(m.r,m.c,opp); board[m.r][m.c]=EMPTY;
      const win = (opp===BLACK? (l===5) : (l>=5));
      if (win) { oppThreat += 1; }
    }

    const center = 7; const dist = Math.abs(r-center)+Math.abs(c-center);

    let score = 0;
    if (color===BLACK) {
      score += 500* (len===4?1:0) + 80*len;
      score += 12000*fours + 2600*threes;
    } else {
      score += 600* (len>=4?1:0) + 90*len;
      score += 10000*fours + 2200*threes;
    }
    score += 40*(10 - Math.min(10, dist));
    score -= 15000 * oppThreat;

    board[r][c]=EMPTY;
    return score;
  }

  function candidateMoves(color){
    let hasStone=false; let minR=N, minC=N, maxR=-1, maxC=-1;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) if (board[r][c]!==EMPTY){
      hasStone=true; if (r<minR) minR=r; if (c<minC) minC=c; if (r>maxR) maxR=r; if (c>maxC) maxC=c;
    }
    const set = new Set(); const res=[];
    if (!hasStone){ return [{r:7,c:7}]; }
    minR=Math.max(0,minR-2); minC=Math.max(0,minC-2); maxR=Math.min(N-1,maxR+2); maxC=Math.min(N-1,maxC+2);
    for (let r=minR;r<=maxR;r++){
      for (let c=minC;c<=maxC;c++){
        if (board[r][c]!==EMPTY) continue;
        let near=false; for (let dr=-2; dr<=2 && !near; dr++) for (let dc=-2; dc<=2 && !near; dc++){
          const rr=r+dr, cc=c+dc; if (inB(rr,cc) && board[rr][cc]!==EMPTY) near=true;
        }
        if (!near) continue;
        const key=r+','+c; if (set.has(key)) continue; set.add(key);
        res.push({r,c});
      }
    }
    const center=7;
    res.sort((a,b)=>{
      const dlmA = lastMove? Math.abs(a.r-lastMove.r)+Math.abs(a.c-lastMove.c): 0;
      const dlmB = lastMove? Math.abs(b.r-lastMove.r)+Math.abs(b.c-lastMove.c): 0;
      if (dlmA!==dlmB) return dlmA-dlmB;
      const da = Math.abs(a.r-center)+Math.abs(a.c-center);
      const db = Math.abs(b.r-center)+Math.abs(b.c-center);
      return da-db;
    });
    return res;
  }

  // ===== Wiring =====
  canvas.addEventListener('click', onClick);
  btnNew.addEventListener('click', ()=> reset());
  btnUndo.addEventListener('click', ()=> undo());
  btnAi.addEventListener('click', ()=> aiMove());
  sideSelect.addEventListener('change', ()=> reset());
  levelSelect.addEventListener('change', ()=> status(`AI level set to ${levelSelect.options[levelSelect.selectedIndex].text}.`));

  // boot
  reset();
})();
</script>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




<script src="site_libs/quarto-html/zenscroll-min.js"></script>
</body></html>